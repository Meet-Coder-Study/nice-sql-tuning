### 6.4 Lock과 트랜잭션 동시성 제어

- 자신이 사용하는 데이터베이스의 Lock 매커니즘과 트랜잭션 동시성 제어에 대한 학습은 필수다!

- 오라클 Lock 종류

  1. DML Lock
     - 어플리케이션 개발 측면에서 가장 중요하게 다뤄야 할 Lock
     - 다중 트랜잭션이 동시에 액세스하는 사용자 데이터의 무결성을 보호해준다
     - DML Lock엔 테이블 Lock과 로우 Lock이 있다
  2. DDL Lock
  3. 래치
     - SGA에 공유된 각종 자료구조를 보호하기 위해 사용
  4. 버퍼 Lock
     - 버퍼 블록에 대한 엑세스를 직렬화하기 위해 사용
  5. 라이브러리 캐시 Lock/Pin
     - 라이브러리 캐시에 공유된 SQL 커서와 PL/SQL 프로그램을 보호하기 위해 사용

- DML 로우 Lock

  - 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지함
  - 같은 로우를 UPDATE/DELETE/INSERT를 시도할때
    - UPDATE, DELETE : 진행중인(아직 커밋하지 않은) 로우를 다른 트랜잭션이 수정할 수 없다
    - INSERT : unique인덱스가 있고 같은 값을 입력하려고 할때 블로킹이 발생한다.
      1. 선행 트랜잭션이 커밋할 동안 후행 트랜잭션은 기다린다
      2. 선행 트랜잭션이 커밋하면 후행 트랜잭션은 실패하고, 선행 트랜잭션이 롤백하면 후행 트랜잭션은 성공한다
  - DML 로우 Lock에 의한 성능 저하를 방지하려면 Lock을 너무 오래 유지하지 않도록 커밋 시점을 조절해야 한다

- DML 테이블 Lock (= TM Lock)

  - 현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 하기 위해 로우 Lock 이전에 테이블 Lock을 설정한다

  - 로우 Lock은 1가지 Lock 모드(배타적 모드)만 사용하는 반면 테이블 Lock에는 여러 Lock 모드(RS, RX, S, SRX, X)가 있다

  - 테이블 Lock을 테이블 전체에 걸리는 Lock이라고 오해하기 쉬운데, 그게 아니라 테이블 Lock을 설정한 트랜잭션이 해당 테이블에서 어떤 작업을 수행중인지 알리는 일종의 푯말이라고 이해하면 좋다 (후행 트랜잭션은 그 푯말을 보고 기다릴지, 포기할지 결정된다)

    - Lock이 해제될때까지 기다린다 or 일정 시간만 기다리다 포기한다 or 기다리지 않고 포기한다

  - 예) DDL을 이용하여 테이블 구조를 변경하려 할때

    - 테이블 구조를 변경하려는 트랜잭션은 해당 테이블에 TM Lock이 설정돼있는지 확인한다

    - RX모드로 설정한 트랜잭션이 하나라도 있다면 작업을 멈춘다
    - DDL이 먼저 수행중이라면 DML을 수행하려는 트랜잭션이 기다린다

- 블로킹 vs 교착상태

  - 블로킹 : 선행 트랜잭션이 설정한 Lock 때문에 후행 트랜잭션이 기다리는 상태
  - 교착상태 : 두 트랜잭션이 각각 특정 리소스에 Lock을 설정한 상태에서 두 트랜잭션 모두 맞은편 트랜잭션의 리소스에 Lock을 설정하려고 하는 상황
    - 오라클에서는 교착상태가 발생하면 이를 먼저 인지한 트랜잭션이 문장 수준 롤백을 진행한 후 에러 메시지를 던진다

- 트랜잭션 동시성 제어는 비관적 동시성 제어와 낙관적 동시성 제어로 나뉜다

  1. 비관적 동시성 제어
     - 사용자들이 같은 데이터를 동시에 수정할 것으로 가정하고, 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회/갱신이 완료될때까지 이를 유지한다
     - `select ... for update`로 비관적 락을 걸 수 있다
     - 동시성을 심각하게 떨어뜨릴 우려가 있지만, `for update wait ...`, `for update nowait` 옵션으로 동시성을 증가시킬 수 있다
  2. 낙관적 동시성 제어
     - 사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정하고, 데이터를 읽을때 Lock을 설정하지 않는다. 읽는 시점에 변경된 데이터인지 반드시 검사해야 한다
     - 모든 컬럼에 대해 변경이 됐는지 확인하거나, 수정시간에 대한 컬럼을 따로 만들어서 수정시간이 변경됐는지 확인한다

- 데이터 품질과 동시성 향상을 위해선

  - for update 사용을 두려워하지 말아야 한다
  - for update가 필요한 상황이면 정확히 사용하고, 번거롭더라도 wait 또는 nowait 옵션을 활용하여 예외처리에 주의를 기울어야 한다
  - 불필요하게 Lock을 오래 유지하지 않고, 트랜잭션의 원자성을 보장하는 범위 내에서 가급적 빨리 커밋해야 한다

- 채번 방식

  - 채번 : 신규 데이터를 입력할때 PK 중복을 방지하기 위한 과정

  - 채번 방식 종류

    1. 채번 테이블

       - 채번하기 위한 별도의 테이블을 관리하는 방식
       - 채번 레코드를 읽어서 1을 더한 값으로 변경하고, 그 값을 새로운 레코드를 입력하는데 사용한다
       - 두 트랜잭션이 중복 값을 채번할 가능성을 원천적으로 방지해준다
       - 장점
         - 범용성이 좋다
         - 중복 레코드 발생에 대비하지 않아도 된다
         - INSERT 과정에 결번을 방지할 수 있다
         - PK가 복합컬럼일때도 사용할 수 있다
       - 단점
         - 채번 레코드를 변경하기 위한 로우 Lock 경합 때문에 성능이 안좋다 (그래서 동시 INSERT가 아주 많으면 사용하기 힘들다)
    2. 시퀀스 오브젝트

       - 시퀀스 오브젝트? 오라클 내부에서 관리하는 채번 테이블

       - 장점
         - 성능이 빠르다
         - 중복 레코드 발생에 대비하지 않아도 된다

       - 단점
         - 테이블 별로 시퀀스 오브젝트를 생성하고 관리하는 부담이 있다
         - 시퀀스 채번 과정에서 Lock에 의한 성능 이슈가 있다 (단, 캐시 사이즈를 적절히 설정하면 빠른 성능을 제공한다)
         - PK가 단일컬럼일때만 사용할 수 있다
         - 결번이 생길 수 있다
    3. MAX + 1 조회
       - 예 : `select max(거래일련번호) + 1 from 거래`의 값을 새로 insert할 row의 pk로 사용
       - 장점
         - 시퀀스나 채번 테이블을 관리하지 않아도 된다
         - 동시 트랜잭션에 의한 충돌이 많지 않으면 성능이 매우 좋다
         - PK가 복합컬럼이어도 사용할 수 있다
       - 단점
         - 레코드 중복에 대비한 세밀한 예외처리가 필요하다
         - 다중 트랜잭션에 의한 동시 채번이 심하면 시퀀스보다 성능이 많이 나빠질 수 있다