# 1장 SQL 처리 과정과 I/O

## 1.1 SQL 파싱과 최적화
### 1.1.1 구조적, 집합적, 선언적 질의 언어
- SQL은 기본적으로 구조적이고 집합적이고 선언적인 질의 언어다
- 원하는 결과집합을 구조적, 집합적으로 선언하지만, 그 결과집합을 만드는 과정은 절차적일 수 밖에 없다 = 프로시저가 필요하다!
- DBMS 내부의 엔진인 옵티마이저가 프로시저를 생성한다 = 프로시저가 대신 프로그래밍 해주는 셈
- 프로시저를 작성하고 컴파일 해서 실행 가능한 상태로 만드는 전 과정을 `SQL 최적화`
### 1.1.2 SQL 최적화
1. SQL 파싱
    - 파싱 트리 생성
    - Syntax 체크
    - Semantic 체크
2. SQL 최적화
3. 로우 소스 생성(실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 단계)
### 1.1.3 SQL 옵티마이저
- 쿼리를 수행하기 위한 실행계획들을 찾아냄
- 데이터 딕셔너리에 미리 수집해둔 오브젝트에 통계 및 시스템 통계 정보를 이용해 각 실행계획의 예상 비용 산정
- 최저 비용을 나타내는 실행계획 선택
### 1.1.4 실행계획과 비용
- MySQL에서 실행 계획을 확인하기 위한 키워드 `EXPLAIN`
- 실행하는 실행계획은 옵티마이저가 비용을 근거로 선택한 것
- 비용은 쿼리를 실행하는 동안 발생할 것으로 `예상되는` `I/O 횟수, 예상 소요 시간`을 표현한 것

**옵티마이저가 실행계획을 세우기 위해 고려하는 수많은 정보들**
    
    - 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
    - 오브젝트 통계: 테이블 통계, 인덱스 통계, (히스토그램을 포함한) 컬럼 통계
    - 시스템 통계: CPU 속도, Single Block I/O 속도, Mutliblock I/O 속도 등
    - 옵티마이저 관련 파라미터
### 1.1.5 옵티마이저 힌트
- 상황에 따라 사용하거나 사용하지 않을 수 있음
- MySQL에서 힌트를 사용하기 위해서 주석 기호에 +를 붙여 작성한다

예시: `SELECT /*+ ... 8/`

## 1.2 SQL 공유 및 재사용
### 1.2.1 소프트 파싱 vs 하드 파싱성
![SGA 구조](/img/IMG_0016.jpg)
- SGA: 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간
- 라이브러리 캐시: SQL파싱, 최적화, 로우 소스 생성 과정을 거친 내부 프로시저는 라이브러리 캐시에 저장되어 재사용된다
- 소프트 파싱: 파싱한 SQL이 라이브러리 캐시에 존재하면 바로 실행
- 하드 파싱: 파싱한 SQL이 라이브러리 캐시에 존재하지 않아서 최적화, 로우 소스 생성과정을 모두 거치는 것
- 재사용 이유? 최적화 과정에 딕셔너리, 통걔 정보를 읽어 효율성을 판단하는 과정은 CPU를 많이 사용하는 과정
### 1.2.2 바인드 변수의 중요
- 라이브러리 캐시에 저장되는 SQL에는 이름이 없다
- SQL자체가 검색을 위한 key -> 대, 소문자, 뛰어쓰기 등 아주 조금만 달라도 매번 하드 파싱하고 캐시에 저장한다
- (중요)!바인드 변수를 사용할 것(자바 PreparedStatement)!

**바인드 변수**
- PL/SQL 또는 SQL 쿼리문에서 WHERE 절에 value 값을 (?) 로 사용하는 변수
- 아래와 같이 파라이터 Driven 방식으로 내부 프로시저를 생성한다

`create procedure LOGIN (login_id varchar2) { ... }`
### 참고 링크
https://myinfrabox.tistory.com/92

### 질문
1. 1.1장 질문
- 데이터 딕셔너리가 뭔가요?
- SQL plus의 Auto trace 기능?
2. 1.2장 질문