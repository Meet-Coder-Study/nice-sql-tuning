# 1장 SQL 처리 과정과 I/O

## 1.1 SQL 파싱과 최적화
### 1.1.1 구조적, 집합적, 선언적 질의 언어
- SQL은 기본적으로 구조적이고 집합적이고 선언적인 질의 언어다
- 원하는 결과집합을 구조적, 집합적으로 선언하지만, 그 결과집합을 만드는 과정은 절차적일 수 밖에 없다 = 프로시저가 필요하다!
- DBMS 내부의 엔진인 옵티마이저가 프로시저를 생성한다 = 프로시저가 대신 프로그래밍 해주는 셈
- 프로시저를 작성하고 컴파일 해서 실행 가능한 상태로 만드는 전 과정을 `SQL 최적화`
### 1.1.2 SQL 최적화
1. SQL 파싱
    - 파싱 트리 생성
    - Syntax 체크
    - Semantic 체크
2. SQL 최적화
3. 로우 소스 생성(실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 단계)
### 1.1.3 SQL 옵티마이저
- 쿼리를 수행하기 위한 실행계획들을 찾아냄
- 데이터 딕셔너리에 미리 수집해둔 오브젝트에 통계 및 시스템 통계 정보를 이용해 각 실행계획의 예상 비용 산정
- 최저 비용을 나타내는 실행계획 선택
### 1.1.4 실행계획과 비용
- MySQL에서 실행 계획을 확인하기 위한 키워드 `EXPLAIN`
- 실행하는 실행계획은 옵티마이저가 비용을 근거로 선택한 것
- 비용은 쿼리를 실행하는 동안 발생할 것으로 `예상되는` `I/O 횟수, 예상 소요 시간`을 표현한 것

**옵티마이저가 실행계획을 세우기 위해 고려하는 수많은 정보들**
    
    - 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
    - 오브젝트 통계: 테이블 통계, 인덱스 통계, (히스토그램을 포함한) 컬럼 통계
    - 시스템 통계: CPU 속도, Single Block I/O 속도, Mutliblock I/O 속도 등
    - 옵티마이저 관련 파라미터
### 1.1.5 옵티마이저 힌트
- 상황에 따라 사용하거나 사용하지 않을 수 있음
- MySQL에서 힌트를 사용하기 위해서 주석 기호에 +를 붙여 작성한다

예시: `SELECT /*+ ... 8/`

## 1.2 SQL 공유 및 재사용
### 1.2.1 소프트 파싱 vs 하드 파싱성
![SGA 구조](/img/pic_1-4.png)
- SGA: 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간
- 라이브러리 캐시(쿼리 캐시): SQL파싱, 최적화, 로우 소스 생성 과정을 거친 내부 프로시저는 라이브러리 캐시에 저장되어 재사용된다
- 소프트 파싱: 파싱한 SQL이 라이브러리 캐시에 존재하면 바로 실행
- 하드 파싱: 파싱한 SQL이 라이브러리 캐시에 존재하지 않아서 최적화, 로우 소스 생성과정을 모두 거치는 것
- 재사용 이유? 최적화 과정에 딕셔너리, 통걔 정보를 읽어 효율성을 판단하는 과정은 CPU를 많이 사용하는 과정
### 1.2.2 바인드 변수의 중요
- 라이브러리 캐시에 저장되는 SQL에는 이름이 없다
- SQL자체가 검색을 위한 key -> 대, 소문자, 뛰어쓰기 등 아주 조금만 달라도 매번 하드 파싱하고 캐시에 저장한다
- (중요)!바인드 변수를 사용할 것(자바 PreparedStatement)!

**바인드 변수**
- PL/SQL 또는 SQL 쿼리문에서 WHERE 절에 value 값을 (?) 로 사용하는 변수
- 아래와 같이 파라이터 Driven 방식으로 내부 프로시저를 생성한다

`create procedure LOGIN (login_id varchar2) { ... }`

## 1.3 데이터 저장 구조 및 I/O 메커니즘
### 1.3.1 SQL이 느린 이유
- SQL이 느린 이유는 디스크 I/O 때문. 디스크 I/O가 SQL 성능을 좌우
- I/O를 진행하는 동안 프로세스는 대기 상태에 빠진다
- 스토리지 성능이 빨라지고 있지만 여전히 시간이 가장 많이 소요되는 작업
### 1.3.2 데이터베이스 저장 구조
- 데이터파일: 디스크 상의 물리적인 OS 파일
- 테이블 스페이스: 세그먼트를 담는 컨테이너, 여러 개의 데이터파일로 구성됨
- 세그먼트: 테이블, 인덱스, LOB컬럼 등과 같이 데이터 저장공간이 필요한 오브젝트, 파니셔닝 되지 않았다면 한 오브젝트는 하나의 세그먼트에 저장됨
    - 테이블 세그먼트 헤더에 익스텐트 맵(각 익스텐트의 첫 번째 블록 DBA 저장)이 있음
- 익스텐트: 공간을 확장하는 단위. 세그먼트 구성요소. 연속된 블록 집합. 세그먼트 공간이 부족하면 테이블스페이스로부터 익스텐트를 추가 할당 받음
    - 한 세그먼트의 익스텐트끼리는 연속된 공간이 아닐 수 있음
- 블록(or 페이지): 실제 데이터가 저장되는 공간. 익스텐트의 구성요소. 한 블록에 저장된 레코드는 모두 같은 테이블 레코드
    - 익스텐트 내의 블록은 서로 인접한 연속된 공간
- DBA(Data Block Address): 데이터 블록이 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지 나타내는 고유 주소값
![그림 1-12](/img/pic_1-12.png)
### 1.3.3 블록 단위 I/O
데이터 I/O 단위는 블록이다. 한 레코드만 읽고 싶어도 그 레코드가 포함된 해당 블록을 통째로 읽음(테이블, 인덱스 모두 해당)
### 1.3.4 시퀀셜 액세스 vs 랜덤 액세스
테이블 또는 인덱스 블록을 액세스하는 방법
- 시퀀셜 액세스: 논리적 혹은 물리적으로 연결된 순서에 따라 차례로 블록을 읽는 방식
    - 인덱스 리프 노드로 범위 검색
    - 테이블 세그먼트 헤더 맵으로 풀 테이블 스캔
- 랜덤 엑세스: 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식
### 1.3.5 논리적 I/O vs 물리적 I/O
- 자주 읽는 블록을 매번 디스크에서 읽는 것은 비효율적! -> 캐싱!
- DB Buffer Cache: 디스크에서 읽은 데이터 블록을 캐시, 공유메모리 영역
- 데이터 블록을 읽을 땐 항상 버퍼 캐시부터 탐색
- 논리적 I/O: SQL을 처리하는 과정에서 메모리 버퍼 캐시에서 발생한 총 블록 I/O
- 논리적 I.O (유사) 메모리 I/O
- 물리적 I/O: 디스크에서 발생한 총 블록 I/O
- 메모리 I/O(전기적 신호) <<<<< 디스크 I/O(액세스 암을 통해 물리적 작용) 대략 10,000배 느림
- 버퍼캐시 히트율(Buffer Cache Hit Ratio, BCHR) = (논리적 I/O - 물리적 I/O) / 논리적 I/O * 100
- OLTP 애플리케이션은 시스템 레벨에서 평균 99% 히트율을 달성해야 한다
- BCHR은 시스템 상황에 따라 달라지므로 물리적 I/O는 결국 통제 불가능한 외생변수
- 논리적 I/O는 내생변수

=>  SQL 튜닝을 통해 논리적 I/O를 줄이고, 그로 인해 물리적 I/O도 줄어들어 성능을 향상시키는 것!
### 1.3.6 Single Block I/O vs Multiblock I/O
- Single block I/O: 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식
    - 인덱스를 사용하는 방식
- Multiblock I/O: 한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식
    - 테이블 전체 스캔
    - 많은 데이터를 가져올 때 multiblcok I/O 단위가 클수록 유리
    - multiblock I/O를 이용해도 인접 블록만 가져올 수 있다(같은 익스텐트 내에서면 여러 블록씩 가져올 수 있다는 이야기!)
### 1.3.7 Table Full Scan vs Index Range Scan
- Table Full Scan이라고 항상 느리고, Index Range Scan이라고 항상 빠른 것이 아니다
- 많은 데이터를 처리하는 집계용 SQL, 배치 프로그램 등은 Table Full Scan을 사용해서 자주 성능이 향상된다
### 1.3.8 캐시 탐색 메커니즘
- Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유한다
- 버퍼캐시는 해시 구조로 관리한다(같은 입력값은 동일한 해시 체인=버킷에 연결)
- 해시 체인에 버퍼 헤더를 담고 있다, 거기서 얻은 포인터로 버퍼 블록을 액세스 한다
![그림 1-27](/img/pic_1-27.png)
- 버퍼캐시, 버퍼캐시 체인은 공유자원이므로 직렬화 메커니즘이 필요하다
    - 캐시버퍼 체인 레치, Lock
    
=> 직렬화 메커니즘으로 경합을 줄이기 위해 SQL 튜닝을 통해 논리적 I/O를 줄여야한다

### 기타
- OLTP: online transaction processing
- DW: data warehouse

### 참고 링크
https://myinfrabox.tistory.com/92

https://velog.io/@sezzzini/%EA%B8%88%EC%9C%B5-IT-ETL-%EA%B3%BC-DW#dw

### 질문
1. 1.1장 질문
- 데이터 딕셔너리가 뭔가요?
- SQL plus의 Auto trace 기능?
2. 1.2장 질문
3. 1.3 장 질문
- 59p Full Scan 중에 Chian이 발생한 로우를 읽을 때도 Single Block I/O 방식으로 발생. Chian이 뭐지,,?
- 인덱스를 이용한 접근은 Single Block I/O를 사용한다고 했는데, 인덱스의 리프 노드로 시퀀셜 액세스 해도 Single Block I/O로 동작할까? Mutliblock I/O로 동작할까?