## 1.2. SQL 공유 및 재사용

### 소프트 파싱 vs 하드 파싱

- 프로시저 :
- 라이브러리 캐시 (Library Cache) : SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간
- SGA(System Global Area) : 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간

![image](https://user-images.githubusercontent.com/53366407/140854035-742dfedd-29cb-4f1b-80df-83ad2c6b4a5c.png)

- 소프트 파싱(Soft Parsing) : SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것
- 하드 파싱(Hard Parsing): 찾는데 실패 해 최적화 및 로우 소스 생성 단계까지 모두 거치는 것

![image](https://user-images.githubusercontent.com/53366407/140854048-0df941c1-6d87-420d-9838-25b8c648f3cc.png)

---

- PostreSQL은 어떤가?
    - PostreSQL에서는 Library Cache라는 개념이 존재 하지 않는다.
    - 대신 Buffer가 존재하는데 아래와 같다.
        - Shared Buffer : 사용자가 요청한 데이터 블록을 저장하는 공간
        - WAL(Write Ahead Log) Buffer : 데이터 변경 사항을 저장하는 버퍼
    - 여기서 Shared Buffer에 존재하면 소프트 파싱이 되고, 아니면 하드 파싱이 된다.
    
  ![image](https://user-images.githubusercontent.com/53366407/140854077-d67ef985-78bd-4b8d-b7e4-67d0e9b252c2.png)    

### SQL 최적화 과정은 왜 하드(Hard)한가

- 옵티마이저가 SQL을 최적화할 때도 데이터베이스 사용자들이 보통 생각하는 것보다 훨씬 많은 일을 수행한다. 즉, 수많은 경우의 수가 존재한다.
- 아래와 같은 정보를 사용해 옵티마이저가 경로를 찾는다.
    - 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
    - 오브젝트 통계 : 테이블 통계, 인덱스 통계, (히스토그램을 포함한) 컬럼 통계
    - 시스템 통계 : CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
    - 옵티마이저 관련 파라미터
- 이러한 작업을 매번 하면 과부하이기 떄문에, 캐시를 두고 소프트 파싱을 진행하는 것이다.

### 바인드 변수의 중요성

- 이름없는 SQL 문제
    - 사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 떄부터 이름을 갖음.
    - 즉, 컴파일한 상태로 딕셔너리에 저장되며 사용자가 삭제 하지 않는 이상 영구적으로 보관된다.
    - 그러나 SQL은 이름이 존재하지 않는다. 그 이유는 SQL 자체가 이름이며, 텍스트 중 작은 하나라도 수정되면 그 순간 다른 객체가 새로 탄생하는 구조이기 때문이다.
    - 일회성 SQL도 많고 무효화된 SQL도 많기 때문에 모두 저장하기에는 많은 공간이 필요하기 때문이다.

- 공유 가능 SQL
    - SQL을 캐시에서 찾기 위해 사용하는 키 값은 SQL문 그 자체다. 동일한 결과를 보여주는 SQL이라고 해도 철자하나라도 다르면 다른 SQL이라고 보는 것이다.
    - 아래와 같이 작성한다고 해보자.
    
    ```jsx
    SELECT * FRO CUSTOMER WHERE LOGIN_ID = '" + login_id + "'";
    ```
    
    - 100만명이 한번에 조회를 하면 모두 하드파싱을 하게 될 것이다.
    - 그래서 프로시저 하나를 공유하면서 재사용하는 것이 마땅하기 때문에 바인드 변수를 사용하게 되는 것이다.
    
    ```jsx
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?
    ```
