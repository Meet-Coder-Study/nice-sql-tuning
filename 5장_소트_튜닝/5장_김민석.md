# 5장 소트 튜닝

## 5.1 소트 연산에 대한 이해

### 소트 수행 과정

- 소트 연산은 메모리와 CPU를 많이 쓴다.
- 처리할 양이 많을 때는 디스크 I/O를 사용하기도 한다.
- 부분범위 처리가 불가해서 OLTP 환경에서 앱 성능을 저하시킨다.
- 따라서, 되도록 소트를 안하도록 SQL를 작성하고 불가피할경우 메모리내에서 수행이 완료되도록 한다.

### 소트 오퍼레이션

- Sort Aggregate
  - 실제 데이터를 정렬하진 않고 Sort Area 사용
  - SUM / MAX / MIN / COUNT
- Sort Order By
  - 실제 소트 실행
- Sort Group By
  - 소팅 알고리즘을 사용해 그룹별 집계 수행
- Sort Unique
  - Unnesting된 서브쿼리가 M쪽 집합이면 메인 쿼리와 조인하기 전에 중복 레코드 제거
- Sort Join
  - 소트 머지 조인
- Windows Sort
  - 분석 함수 수행

## 5.2 소트가 발생하지 않고록 SQL 작성

### Union vs. Union All

Union All은 소트 안함. 중복 가능성 없을 경우 Union All 사용하자.

### Exists 활용

중복 레코드를 제거할 목적으로 Distinct 사용하면 부분범위 처리도 불가할뿐더러 디스크 I/O도 발생한다.

Exists 서브쿼리는 데이터 존재 여부만 확인하면 되기 때문에 조건절을 만족하는 데이터를 모두 읽지 않는다.

Distinct, Minus 연산자를 사용한 쿼리는 대부분 Exists 서브쿼리로 변환 가능하다.

### 조인 방식 변경

조인 방식을 변경하는 것만으로 소트 연산 생략이 가능하다.


## 5.3 인덱스를 이용한 소트 연산 생략

### Sort Order By 생략

조건절을 고려한 인덱스 생성으로 소트 연산 생략 가능

### Top N 쿼리

소트가 되어 있는 상황에서 Top N은 필요한 만큼만 연산을 수행한다.

대표적으로 페이징이 있다.(물론 뒤쪽 페이지를 select하면 그만큼 많이 읽는다.)

### 최소값/최대값 구하기

인덱스를 사용하면 바로 읽어올 수 있다.
이때, 조건절 컬럼과 MIN/MAX 함수 인자 컬럼이 모두 인덱스에 포함돼 있어야 한다.

### 이력 조회


### Sort Group By 생략

인덱스를 사용하여 Sort Group By 연산 생략이 가능하다. 이때 부분범위 처리도 가능하다.


## 5.4 Sort Area를 적게 사용하도록 SQL 작성

### 소트 데이터 줄이기

트레이스를 하면서 소트의 데이터량을 직접 비교해 봐야한다.

### Top N 쿼리의 소트 부하 경감 원리

Top N  소트 알고리즘을 사용하여 공간 절약 가능.

### 분석함수에서의 Top N 소트

윈도우 함수 중 rank / row_number 함수는 max 함수보다 소트 부하가 적다. Top N 소트 알고리즘이 작동하기 때문이다.







