# 5.1 소트 연산에 대한 이해
## 5.1.1 소트 수행 과정 
소트는 기본적으로 PGA 에 할당한 Sort Area 에서 이루어진다.

메모리 공간인 Sort Area 가 다 차면, 디스크 Temp 테이블 스페이스를 활용한다.

- 소트 유형
    - 메모리 소트
    - 디스크 소트

<br>

# 5.2 소트가 발생하지 않도록 SQL 작성
## 5.2.1 Union vs Union ALl
- Union
    - 옵티마이저는 상단과 하단 두 집합 간 중복을 제거하려고 소트 작업을 수행한다.
  

- Union All
    - 중복을 확인하지 않고 두 집합을 단순히 결합 
    - 소트 작업을 수행하지 않는다.
    - 두 집합이 상호 배타적일때 사용해도 된다.
  
## 5.2.2 Exist 활용
- Distinct
    - 조건에 해당하는 데이터를 모두 읽어서 중복을 제거한다. 
    - 따라서 많은 I/O 가 발생한다.


- Exist
    - 데이터의 존재 여부만 확인하면 되기 떄문에 모든 데이터를 읽지 않는다.
    - [같이 보면 좋은 글](https://jojoldu.tistory.com/516) 


<br>

# 5.3 인덱스를 이용한 소트 연산 생략 
## 5.3.1 Sort Order By 생략
모든 데이터를 다 읽어 정렬을 마치고 출력을 시작하면 OLTP 환경에서 요구되는 빠른 응답 속도를 내기 어렵다.

따라서 인덱스 선두 컬럼에 조건을 구성하여 쿼리에서 소트 연산을 생략하도록 하자.

인덱스는 항상 키 컬럼 순으로 정렬된 상태를 유지하기 때문에 적절하게 쿼리를 작성하면 소트 연산을 생략할 수 있다.

<br>

** 3-Tier 환경

클라이언트 - WAS - DB 로 구성된 구조

해당 아키텍처는 수 많은 클라이언트가 서버 리소스를 공유하는 구조이기 때문에 클라이언트가 특정 DB 커넥션을 독점할 수 없다.

독점을 하게 된다면 커넥션 풀이 말라 이슈가 발생할 것이다.

<br>

# 5.4 Sort Area 를 적게 사용하도록 SQL 작성 
소트 연산이 불가피하다면 메모리 내에서 처리를 완료할 수 있도록 노력해야 한다.

가장 중요한 것은 Sort Area 를 적게 사용할 방법부터 찾는 것이다.

## 5.4.1 소트 데이터 줄이기
#### Case 1.
- 일반 쿼리 / 서브 쿼리
    - 서브 쿼리를 사용하면 가공하지 않은 상태로 정렬을 완료하고 나서 최종 출력할 때 가공한다.
    - 따라서 Sort Area 를 훨씬 더 적게 사용한다.

#### Case 2.
- Select * / Select XX, TT
    - Select XX, TT 이 Sort Area 를 더 적게 사용한다.
    - 왜냐하면 XX, TT 두 필드만 저장하기 때문이다.
  