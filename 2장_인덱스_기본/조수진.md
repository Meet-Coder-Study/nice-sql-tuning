# 2장. 인덱스 기본

## 2.1 인덱스 구조 및 탐색
### 2.1.1 미리 보는 인덱스 튜닝
**데이터베이스 테이블에서 자료를 찾는 방법**
1. 테이블 풀 스캔
2. 인덱스 이용

**인덱스 튜닝의 핵심 요소**
- 인덱스 스캔 효율화 튜닝
- 랜덤 액세스 최소화 튜닝

**Tip!** DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기 위해 개발됨
### 2.1.2 인덱스 구조
인덱스는 B*Tree 구조 = 정렬됨 = 범위 스캔이 가능하다

**BTree 구성**
- 루트 노드
- 브랜치 노드
- 리프 노드
 
**루트와 브랜치 블록의 구성**
- 각 레코드는 하위 블록에 대한 주소값을 가짐
- key 값을 가지고, 키 값은 하위 블록에 저장된 키 값의 범위를 나타냄
    
    ex) 서 → 연결된 블록은 서보다 크거나 같은 레코드가 저장됌
    
- LMC: leftmost child 가장 왼쪽에 위치한 블럭을 가리킴
    
    → 첫 번째 키값을 가진 레코드보다 작거나 같은 레코드가 저장됌

**리프 블록의 구성**
- 정렬된 key 값
- 테이블 레코드를 가리키는 주소값(=ROWID)

ROWID = DBA(Data block address) + 로우 번호

= 데이터 파일 번호 + 블록 번호 + 로우 번호

**수직적, 수평적 탐색**
- 수직적 탐색: 인덱스 스캔 시작 시점을 찾는 과정
- 수평적 탐색: 데이터를 찾는 과정
### 2.1.3 인덱스 수직적 탐색
조건을 만족하는 첫 번째 레코드를 찾는 과정

→ 찾고자 하는 값 보다 크거나 같은 레코드(key)를 찾으면 그 직전 레코드가 가리키는 하위 블록으로 이동

→ 찾고자 하는 값과 같은 레코드를 찾아도 그 직전 레코드가 가리키는 하위 블록으로 가야 조건을 만족하는 '첫번째' 블록을 찾을 수 있음
### 2.1.4 인덱스 수평적 탐색
실제 데이터를 찾는 과정

= 리프 블록에서 수평적으로 탐색하면서 찾고자 하는 데이터가 더 안나타날 때까지 스캔

→ 인덱스 리프는 더블 링크드 리스트 구조
### 2.1.5 결합 인덱스 구조와 탐색
결합 인덱스: 두 개 이상의 컬럼을 결합해서 인덱스를 만드는 것

인덱스를 (고객명, 성별)로 구성하든, (성별, 고객명)으로 구성하든 읽는 인덱스 블록 개수는 똑같다

where에서 '=' 조건 검색할 때는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같다(= 성능이 똑같다)

인덱스 구성에 따라 성능 차이가 나는 것은 맞지만, 엑셀의 필터처럼 생각하면 안된다!

### 질문
- 83p: 루트로부터 모든 리프 블록까지 높이가 항상 같다 → 대량으로 insert되거나 delete되는 경우는 바로 밸런싱되나?
- 그림 2-1 리프 노드가 논리적으로는 시퀀셜인데 실제 물리적으로 연결된 곳에 위치하는 건 아니지 않을까,,,?