# 2장. 인덱스 기본

## 2.1 인덱스 구조 및 탐색
### 2.1.1 미리 보는 인덱스 튜닝
**데이터베이스 테이블에서 자료를 찾는 방법**
1. 테이블 풀 스캔
2. 인덱스 이용

**인덱스 튜닝의 핵심 요소**
- 인덱스 스캔 효율화 튜닝
- 랜덤 액세스 최소화 튜닝

**Tip!** DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기 위해 개발됨
### 2.1.2 인덱스 구조
인덱스는 B*Tree 구조 = 정렬됨 = 범위 스캔이 가능하다

**BTree 구성**
- 루트 노드
- 브랜치 노드
- 리프 노드
 
**루트와 브랜치 블록의 구성**
- 각 레코드는 하위 블록에 대한 주소값을 가짐
- key 값을 가지고, 키 값은 하위 블록에 저장된 키 값의 범위를 나타냄
    
    ex) 서 → 연결된 블록은 서보다 크거나 같은 레코드가 저장됌
    
- LMC: leftmost child 가장 왼쪽에 위치한 블럭을 가리킴
    
    → 첫 번째 키값을 가진 레코드보다 작거나 같은 레코드가 저장됌

**리프 블록의 구성**
- 정렬된 key 값
- 테이블 레코드를 가리키는 주소값(=ROWID)

ROWID = DBA(Data block address) + 로우 번호

= 데이터 파일 번호 + 블록 번호 + 로우 번호

**수직적, 수평적 탐색**
- 수직적 탐색: 인덱스 스캔 시작 시점을 찾는 과정
- 수평적 탐색: 데이터를 찾는 과정
### 2.1.3 인덱스 수직적 탐색
조건을 만족하는 첫 번째 레코드를 찾는 과정

→ 찾고자 하는 값 보다 크거나 같은 레코드(key)를 찾으면 그 직전 레코드가 가리키는 하위 블록으로 이동

→ 찾고자 하는 값과 같은 레코드를 찾아도 그 직전 레코드가 가리키는 하위 블록으로 가야 조건을 만족하는 '첫번째' 블록을 찾을 수 있음
### 2.1.4 인덱스 수평적 탐색
실제 데이터를 찾는 과정

= 리프 블록에서 수평적으로 탐색하면서 찾고자 하는 데이터가 더 안나타날 때까지 스캔

→ 인덱스 리프는 더블 링크드 리스트 구조
### 2.1.5 결합 인덱스 구조와 탐색
결합 인덱스: 두 개 이상의 컬럼을 결합해서 인덱스를 만드는 것

인덱스를 (고객명, 성별)로 구성하든, (성별, 고객명)으로 구성하든 읽는 인덱스 블록 개수는 똑같다

where에서 '=' 조건 검색할 때는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같다(= 성능이 똑같다)

인덱스 구성에 따라 성능 차이가 나는 것은 맞지만, 엑셀의 필터처럼 생각하면 안된다!

## 2.2 인덱스 기본 사용법

### 2.2.1 인덱스를 사용한다는 것

Index Full Scan vs Index Range Scan

일반적으로 인덱스를 정상적으로 사용한다는 것은 Index Range Scan을 의미

= 리프 블록에서 스캔 시작점을 찾아서 중간에 멈추는 지점을 찾아 색인을 멈추는 것

→ 인덱스 컬럼(정확히는 선두 컬럼)을 가공하거나 인덱스의 중간에 포함된 값으로 색인을 하고자 하는 경우 Index Range Scan이 불가능하고 Index Full Scan을 할 수 밖에 없다

### 2.2.2 인덱스 Range Scan 할 수 없는 이유

아래와 같이 컬럼을 가공하는 경우, 컬럼의 중간에 위치하는 값으로 검색하는 경우, or이나 in 절로 검색하는 경우는 Index Range Scan이 불가능하다

하지만 Or, In 절은 옵티마이저의 쿼리 변환 기능을 통해 여러 개의 Index Range Scan으로 처리되기도 한다

→ IN-List Iterator 방식, union all

where substr(생년월일, 5, 2) = ‘05’

where nvl(주문수량, 0) < 100

where 업체명 like ‘%대한%’

where (전화번호 =: tell_no or 고객명 =: cust_nm)

where 전화번호 in (:tell_no1, :tell_no2)

### 2.2.3 더 중요한 인덱스 사용 조건

인덱스 Range Scan을 하기 위해서는 반드시 **인덱스 선두 컬럼**이 **가공되지 않은 상태로** 조건절에 있어야 한다

그렇다면 무조건 Range Scan은 가능하다

하지만 인덱스를 잘 탄다고 해서 튜닝이 끝난 것은 아니다

예를 들어, 인덱스가 `주문일자 + 상품번호` 순으로 구성되어 있고, 하루 평균 100만 건의 데이터가 쌓인다면

`Select * from 주문상품 where 주문일자 =: ord_dt and 상품번호 like ‘%ping%’;`

위의 쿼리는 매 번 100만 건의 데이터를 스캔해야함!

### 2.2.4 인덱스를 이용한 소트 연산 생략

인덱스는 정렬된 상태로 저장되어 있다 → select 의 order by 연산을 생략할 수 있다

오름 차순의 경우, 조건을 만족하는 가장 작은 값부터 왼쪽에서 오른쪽으로 스캔을 하고,

내림차순의 경우 조건을 만족하는 가장 큰 값인 오른쪽에서부터 왼쪽으로 스캔함

### 2.2.5 ORDER BY 절에서 컬럼 가공

`select * from (select to_char(a.주문번호, ‘FM000000’) as 주문번호, a.업체번호, a.주문금액 from 주문 a where a.주문일자 =: dt and a.주문번호 > NVL(:next_ord_no, 0) order by 주문번호) 
where rownum < = 30`

→ order by 절에 사용된 주문번호는 to_char로 가공된 주문번호 → sort 가 일어어난다

→ a.주문번호로 바꿔주면 sort 생략가능

### 2.2.6 SELECT-LIST에서 컬럼 가공

`SELECT MIN(변경순번) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180316'`

`SELECT MAX(변경순번) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180316'`

→ 인덱스를 이용해 정렬 연산 없이 최소, 최대값을 빠르게 찾을 수 있다

실행계획에는 INDEX RANGE SCAN (MIN/MAX) 상태변경이력_PK, FIRST ROW라고 뜸

`SELECT NVL(MAX(TO_NUMBER(변경순번)), 0) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180316'`

→ 이런식으로 짜면 인덱스 컬럼에 수정이 생기므로 정렬 연산을 줄일 수 없다

⇒ `SELECT NVL(TO_NUMBER(MAX(변경순번)), 0) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180316'`로 수정 가능

- 서브 쿼리에서 사용할 경우도 마찬가지

```sql
SELECT 장비번호, 장비명, 상태코드
        , (SELECT MAX(변경일자))
        FROM 상태변경이력
        WHERE 장비번호 = P.장비번호) 최종변경일자
        , (SELECT MAX(변경순번)
        FROM 상태변경이력
        WHERE 장비번호 = P.장비번호
        AND 변경일자 = (SELECT MAX(변경일자)
                        FROM 상태변경이력
                        WHERE 장비번호 = P.장비번호)) 최종변경순번
FROM 장비 P
WHERE 장비구분코드 = 'A001'
```

### 2.2.7 자동 형변환

조건절에서 입력되는 데이터 타입과 실제 테이블 타입이 다르면 컴파일 시점에 에러를 내는 DBMS도 있고 Oracle처럼 형변환해주는 DBMS도 있다. 인덱스 컬럼에 자동 형변환이 걸리면 인덱스 사용이 불가능하거나 효율이 떨어지므로 주의해야함!

- 우선 순위: 숫자형 > 날짜형 > 문자형
    
    ex. `SELECT * FROM 고객 WEHRE 생년월일 = 19821225`
    

→ 문자열 타입인 생년월일이 숫자 타입으로 형변환되면서 인덱스를 사용할 수 없게 됨 ⇒ 테이블 풀스캔

- Like는 문자열 비교 연산자이므로 문자형 기준으로 숫자형 컬럼이 변환된다
    
    ex. `SELECT * FROM 고객 WEHRE 고객번호 LIKE '9410%'` ⇒ 테이블 풀스캔
    
- 형변환에 의해 실행 에러가 발생할 수 있다
    
    ex. 문자형 컬럼을 숫자형으로 변경할 때, 숫자로 변경할 수 없는 문자열이 있는 경우
    
- 형변환에 의해 결과 오류가 발생할 수 있다
    
    ex. `select round(avg(sal)) avg_sal, min(sal) min_sal, max(sal) max_sal, max(decode(job, 'PRESDENT', NULL, sal)) max_sal2 from emp`
    
    → president를 제외한 급여 중 가장 큰 급여 값이 950으로 나온다
    
    → decode(a, b, c, d)를 처리할 때, a=b이면 c를 반환하고 아니면 d를 반환. 그 때, 데이터 타입은 세번째 인자 c에 의해 결정되는데, Null은 varchar2로 취급된다
    
    ⇒ sal이 문자열로 리턴되고 문자열 기준 max가 동작됨
    

⇒ 결론! 자동 형변환에 의존하지말고 명시적으로 형변환 해줄 것(TO_CAHR, TO_DATE, TO_NUMBER)

## 2.3 인덱스 확장기능 사용법

### 2.3.1 Index Range Scan

- BTree인덱스의 가장 일반적이고 정상적인 액세스 방식
- 인덱스 루트에서 리프 블록까지 수직적 탐색 → 필요한 범위 스캔
- 인덱스의 선두 컬럼을 가공하지 않은 상태로 조건절에서 사용해야 한다
- 성능을 위해서는 인덱스를 스캔하는 범위, 테이블 액세스 횟수를 얼마나 줄일 수 있느냐로 결정된다

### 2.3.2 Index Full Scan

- 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
- 데이터 검색을 위한 최적의 인덱스가 없을 때, I/O를 줄이기 위해 Table Full Scan 대신 차선으로 사용
    
    (ex. 대용량 테이블이어서 Table Full Scan 비용이 크다면 = 대용량 데이터 중 아주 일부 테이블을 액세스 하는 상황)
    

```sql
create index emp_ename_sal_idx on emp (ename, sal);
select * from emp where sal > 2000 order by ename;
```

- 정렬된 결과를 쉽게 얻기 위해(소트 연산을 생략) 옵티마이저가 전략적으로 선택할 수 있다
    
    → first rows 힌트로 옵티마이저 모드를 변경해서 최초 N건 조회. But fetch를 멈추지않고 데이터를 끝까지 읽는다면 Table Full Scan보다 느리다
    

```sql
select /*+ first_rows */from emp where sal > 1000 order by ename;
```

### 2.3.3 Index Unique Scan

- 수직적 탐색만으로 데이터를 찾는 스캔 방식
- Unique 인덱스를 '='조건으로 탐색하는 경우
- Unique 인덱스라도 범위 검색(between, 부등호, like)을 할 때는 Index Range Scan
- Unique 결합 인덱스에 대해 일부 컬럼으로만 검색할 때도 Index Range Scan

### 2.3.4 Index Skip Scan

- 오라클 9i에서 새로 선보인 스캔 방식(MySQL에서는 Loose Index Scan)
- 조건절에 부합하는 레코드를 포함할 '가능성이 있는' 리프 블록만 골라서 액세스하는 스캔 방식
- index_ss, no_index_ss 힌트를 사용해서 스캔 방식 유도
- 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용
- 인덱스의 빠진 컬럼의 경계 조건에 해당하는 블럭은 꼭 포함해야함!
- 적용 예시: 복합 인덱스의 선두 혹은 중간 컬럼이 없는 경우, 선두 컬럼이 범위 조건인 경우
- Index Range Scan이 불가능하거나 효율적이지 못한 상황에서 Index Skip Scan을 차선으로 택할 수 있다

### 2.3.5 Index Fast Full Scan

- Index Full Scan 보다 빠르다
- 이유: 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 스캔
    - 루트와 브랜치도 읽지만 필요없는 정보라 버림
    - 속도는 빠르지만 결과 지합이 인덱스 키 순서대로 정렬되지 않음
    - 쿼리에서 사용한 컬럼이 모두 인덱스에 포함되어 있어야 사용 가능
- index_ffs, no_index_ffs 힌트 사용
- Index Range Scan, Index Full Scan과 달리 인덱스가 파티션 돼 있지 않더라도 병렬 쿼리(스캔) 가능
- 병렬 쿼리 시에는 Direct Path I/O 방식을 사용해서 I/O 속도가 더 빨라진다

### 2.3.6 Index Range Scan Descending

- Index Range Scan과 기본적으로 동일
- 뒤에서부터 앞으로 스캔하기 때문에 내림차순으로 정렬된 결과 집합을 얻는다

### 질문
- 83p: 루트로부터 모든 리프 블록까지 높이가 항상 같다 → 대량으로 insert되거나 delete되는 경우는 바로 밸런싱되나?
- 그림 2-1 리프 노드가 논리적으로는 시퀀셜인데 실제 물리적으로 연결된 곳에 위치하는 건 아니지 않을까,,,?
- union all?? union은 합집합 기능
- 99p 참고로 애초에 발견한 SQL의 ORDER BY 절에는 ‘주문번호’가 아니라 ‘1’이라고 적혀있었다. ‘1’은 SELECT-LIST에 나열된 첫 번째 컬럼을 의미한다??? 무슨말이지!
- select-list → SELECT와 FROM 사이 - 원하는 COLUMN(속성)만 조회
- 102p 마지막 쿼리 이해가 잘 안됨,, SUBSTR? || 가 인덱스 컬럼을 가공?
- cr, pr? 읽은 블록?