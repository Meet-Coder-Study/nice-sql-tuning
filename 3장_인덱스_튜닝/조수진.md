# 3.1 테이블 액세스 최소화

### 3.1.1 테이블 랜덤 액세스

- 인덱스로 검색해도 빠른데 왜 파티셔닝을 할까?
- 인덱스로 검색하는데 왜 느릴까?

### ROWID

- 커버링 인덱스가 아닌 경우 원하는 자료를 찾기 위해 ROWID로 테이블에 액세스 해야한다
- 인덱스의 ROWID는 포인터(물리 주소)가 아니다. 논리 주소이다!(메모리 DB 인덱스는 포인터)

### 인덱스를 이용한 I/O

- ROWID를 분해해서 DBA 정보 확인
- 해싱 결과로 해시 체인 찾기(래치 획득)
- 해시 체인 내부에서 버퍼 헤더 찾기(버퍼 캐시의 메모리 주소)
- 버퍼 헤더가 있으면 포인터로 버퍼 블록 찾아가기(&pinning 포인터 유지)
- 버퍼 헤더가 없으면 디스크에서 데이터 파일 → 블록 → 레코드 찾아가서 캐시에 로딩 & 결과 리턴

→ 버퍼 캐시에서 테이블 블록이 수시로 밀려났다 다시 캐싱됨

⇒ 인덱스에서 포인터 사용할 수 X

⇒ 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용이다!

![Untitled](/img/pic3-3.png)

### Table Full Scan I/O

- 테이블 세그먼트 헤더에 익스텐트 맵 확인
- 익스텐트 맵을 통해 각 익스텐트의 첫 번째 블록 DBA를 알 수 있음
- 익스텐트 내부의 블록은 연결되어 있으므로 시퀀셜하게 읽으면됨

### 3.1.2 인덱스 클러스터링 팩터

특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미 = 군집성 계수

익덱스 레코드 정렬 순서와 실제 테이블 정렬 순서가 비슷하면 테이블 액세스량에 비해 블록 I/O가 적게 발생함

→ 버퍼 Pinning(인덱스 ROWID로 테이블 액세스 할 때, 래치 획득과 체인 스캔 후 블록에서 데이터를 읽고 포인터 그대로 유지)

### 3.1.3 인덱스 손익분기점

ROWID로 테이블 액세스는 고비용 구조

→ 읽어야 할 데이터가 일정량 이상 넘어가면 테이블 풀스캔이 효과적일수도

⇒ Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 인덱스 손익분기점

- 보통 10~100만건 이내 테이블에서 손익 분기점은 5~20% 수준, CF에 따라 크게 달라진다
- 테이블 풀스캔은 1000건을 조회하든, 1000만건을 조회하든 성능이 거의 일정하다
    
    → 시퀀셜 액세스, Multiblock I/O라서
    

### OLTP 튜닝

- 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 중요
- NL 조인 사용
- 인덱스로 소트 연산 생략

### 배치 프로그램 튜닝

- 전체범위 처리 기준으로 튜닝해야 한다
- 처리 대싱 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표로
- 대량 데이터를 빠르게 처리하려면 Full Scan과 해시 조인이 유리
- 초대용량 테이블을 Full Scan하면 오래 걸리기 때문에 배치 프로그램은 파티션 활용 전략이 매우 중요한 튜닝 요소
- 파티셔닝은 Full Scan을 빠르게 처리하기 위함

### 3.1.4 인덱스 컬럼 추가

테이블 액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼 추가 하는 것

- 인덱스 스캔 후, 테이블 액세스 과정에서 필터되는 데이터가 많은 경우 사용

cr - Consistent Read(Consistent Read Mode로 버퍼 캐시에서 특정 블록을 읽는 것)

pr - Physical Read(특정 블록을 읽어서 버퍼 캐시에 로딩)

### 3.1.5 인덱스만 읽고 처리

### Covered 쿼리, Covered 인덱스

쿼리에 사용되는 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않도록 하는 방법

### Include 인덱스

인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능(최대 1023 컬럼까지 지정 가능)

- 커버링 인덱스랑 차이점: 커버링 인덱스와 달리 수직 탐색에 사용할 수 없다, 정렬도 X
- 인덱스 생성 시, `include (sal)`

### 3.1.6 인덱스 구조 테이블

- 클러스터형 인덱스, IOT
- 인덱스 리프 블록에서 테이블 블록에 있어야 할 데이터를 모두 저장
- 인위적으로 클러스터링 팩터를 좋게 만드는 방법 → 시퀀셜 데이터 액세스
- 테이블 생성할 때, `organization index` 작성(기본 테이블은 힙 구조 테이블)

### 3.1.7 클러스터 테이블

- 인덱스를 이용한 클러스터, 해시 클러스터 존재

### 질문

- 129p 파티션 pruning: 하드 파싱이나 실행 시점에서 SQL 조건절을 분석해서 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외시키는 기능
- 콤마는 암시적 inner join
- 랜덤 I/O를 줄여야한다고 할 때, 디스크 블록 I/O(테이블 액세스)만 말하는 게 아니라 버퍼 캐시 읽는 것도 포함인듯?
- 142p 실행 계획 읽는 순서?
- 윈도우 함수?
- include의 커버링 인덱스 대비 우위점: 갱신 시 인덱스 트리 재정렬 오버헤드 X
- 152p 클러스터링 인덱스가 수정되면 데이터 전체 재정렬?
- 클러스터 vs 파티셔닝 → 파티셔닝 테이블을 물리적으로 분리해서 I/O 경합으르 줄이기 위함, 클러스터는 CF를 높이기 위한 목적
- 클러스터 없이 쓰면 배치로 여러 데이터 입력되도 다른 블록에 저장될까? CF 나빠질까?

[SQL 실행계획(Explain Plan) 해석/읽는 법](https://m.blog.naver.com/jump_penguin/20193916878)

# 3.2 부분범위 처리 활용

### 3.2.1 부분범위 처리

- DBMS는 클라이언트에게 데이터를 전송할 때 일정량씩 나누어 전송
- 일정량(Array Size) 전송하고 서버 프로세스는 CPU를 OS에 반환
- 클라이언트로부터 Fetch Call을 받기 전까지 서버 프로세스는 대기 큐에서 그대로 멈춰 기다림
- 정렬 조건이 있으면 정렬을 완료한 후 전송할 데이터를 나눌 수 있기 때문에 성능 개선 불가능
- 정렬 조건이 인덱스의 선두에 있으면 부분 범위 처리 가능
- 대량 데이터를 파일로 내려받는다면 어차피 데이터를 모두 전송해야 하므로 Array Size를 크게 하고 Fetch Call을 줄임
- 일부 데이터만 Fetch하다가 멈추는 프로그램은 Array Size를 작게 설정하는 것이 유리

### 3.2.2 부분범위 처리 구현

Array Size에 도달하면 멈추었다가 사용자 요청이 있을 때 다시 데이터를 Fetch하는 부분이 필요하다

### 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리

클라이언트 - DB 서버 2-Tier 환경은 일부만 출력하고 멈출 수 있다

클라이언트와 DB 사이에 WAS, AP 서버 등이 존재하는 n-Tire는 클라이언트가 특정 DB 커텍션을 독점할 수 없 → 5.3장에서 방법 설명

# 3.3 인덱스 스캔 효율화

### 3.3.3 액세스 조건과 필터 조건

- 인덱스 액세스 조건: 인덱스 스캔 범위를 결정하는 조건절
- 인덱스 필터 조건: 테이블로 엑세스 할지 결정하는 조건절
- 테이블 필터 조건: 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지 결정

### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

- 인덱스 엑세스 조건: 선행 컬럼이 '='인 조건 상태에서 첫 번째로 나타나는 범위 검색 조건까지
    
    → 조건에 만족하는 인덱스 레코드는 연속해서 모여있음
    
- 인덱스 필터 조건: 그 이후는 비교 연산자 종류에 상관없이 결과가 흩어짐
### 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

- 인덱스 스캔 효율은 인덱스 커럼을 모두 등치(=) 조건으로 사용할 때 가장 좋다
- 인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도 뒤쪽 컬럼일 때는 비효율이 없다
    - ex. 인덱스 on (아파트시세코드, 평형, 평형타입, 인터넷 매물) → `where 아파트시세코드 =: a`
- 인덱스 선행 컬럼이 조건절에 없거나, 부등호, BETWEEN, LIKE 같은 범위 검색 조건이면 인덱스를 스캔하는 단계에서 비효율이 생긴다

### 3.3.6 BETWEEN을 IN-List로 전환

- Between 절을 IN-List로 변경해서 개선할 수 있다
    
    → INLIST ITERATOR 오퍼레이션 발생(IN절의 각 값에 대해 수직 탐색 반복 진행)
    
    → IN-LIST에 있는 값을 등치 조건으로 실행 후 union all 실행
    
    → IN-List 항목이 늘어날 수 있으면 불가능(between 값 사이에 현재 알고 있는 값 이외에 추가 발생)
    
    → IN-List 개수가 많으면 리프 블록 탐색 스캔 비용보다 루트에서 브랜치 블록까지를 반복 스캔하는 I/O 비용이 클 수 있음
    
    → 인덱스 스캔 과정에서 선택되는 레코드들이 멀리 떨어져있을 때 유용
    

### 3.3.7 Index Skip Scan 활용

선두 컬럼이 Between이어서 나머지 검색 조건을 만족하는 데이터들이 멀리 떨어져있을 때, IN-List대신 Index Skip Scan으로 개선 가능

- 인덱스 on (판매월, 판매 구분)
- select (*) from 월별고객별판매집계 t where 판매구분 ='A' and 판매월 between '201801' and '201812'
- 블록 I/O 비교: 인덱스 변경 > Skip Scan > IN-LIST >> Between

### 3.3.8 IN 조건은 '='인가

- IN 조건은 '='이 아니다
- '='이 되려면 IN-LIST Iterator로 풀어서 액세스 조건으로 만들어야 한다
- 그렇지 않으면 IN 조건은 필터 조건이다
- IN 조건이 액세스 조건이 된다고 항상 효과적인 것이 아니다
- `NUM_INDEX_KEYS` 힌트로 IN-List 액세스 조건 또는 필터 조건으로 유도할 수 있다
    - 세 번째 인자 값(ex. 1)으로 주어진 칼럼까지만 액세스 조건으로 사용
- 힌트 없이 필터 조건으로 사용하고 싶은 컬럼을 가공(ex. RTRIM, || '' 등 )할 수 도 있음 → 인덱스 사용 X

### 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

- LIKE보다 BETWEEN을 사용하는 게 낫다
- BETWEEN은 양 끝단의 레코드 시작점, 멈추는 지점이 설정되여 효율적일 수 있음
- 그러나 LIKE는 양 끝단의 조건 레코드를 모두 훑어야함

### 3.3.10 범위 조건 검색을 남용할 때 생기는 비효율

```sql
<쿼리1> 회사코드, 지역코드, 상품명을 모두 입력할 때
SELECT 고객ID, 상품명, 지역코드, ...
FROM 가입상품
WHERE 회사코드 =: com
AND 지역코드 =: reg
AND 상품명 LIKE :prod || '%'

<쿼리1> 회사코드, 상품명을 모두 입력할 때
SELECT 고객ID, 상품명, 지역코드, ...
FROM 가입상품
WHERE 회사코드 =: com
AND 상품명 LIKE :prod || '%'
```

```sql
<쿼리3> 회사코드, 상품명, 지역코드,,,
SELECT 고객ID, 상품명, 지역코드, ...
FROM 가입상품
WHERE 회사코드 =: com
AND 지역코드 LIKE :reg || '%'
AND 상품명 LIKE :prod || '%'
```

→ 2가지 상황에 따라 처리해야하는 쿼리를 효율적으로 개발하기 위해 쿼리 3으로 변경하면 지역코드가 입력되어도 지역 코드가 액세스 조건으로 사용되지 못하고 필터 조건으로 사용됨

⇒ 개발 생산성은 좋아질지 몰라도 인덱스 스캔의 비효율이 생긴다. 특히 대량 테이블을 넓은 범위로 검색할 때 영향이 매우 클 수도 있다

### 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

옵션처리를 위해 아래와 같이 다양한 방법이 있다. 성능 개선을 위해 가장 다루기 어려운 주제이다. 여러 방식의 장단점을 이해해서 상황에 따라 선택해야한다.

1. OR 조건 활용
    
    ```sql
    select * from 거래
    where (:cust_id is null or 고객ID = :cust_id)
    and 거래일자 between :dt1 and dt2
    ```
    
    - 옵티마이저의 OR Expansion이 자동으로 적용되지 않는다
        
        → 선행조건에 Or 사용시 인덱스 사용X
        
        → 후행조건에서 사용시, 필터로 사용되지만 oracle는 null을 인덱스에 저장하지 않기 때문에 테이블 액세스 단계에서 필터링
        
    - 인덱스에 포함되지 않은 컬럼에 대해 옵션 조건은 어차피 테이블 스캔에서 필터링해야하므로 써도 상관없음
    
    ⇒ 인덱스 액세스 조건으로 사용 불가, 인덱스 필터 조건으로도 사용 불가, 테이블 필터 조건으로만 사용 가능(NotNull 조건 컬럼은 18c부터 인덱스 필터 조건 사용 가능)
    
    아래의 경우에는 OR Expansion을 통해 인덱스 사용 가능
    
    ```sql
    select * from 거래 where 고객ID = :custd_id
    and ((:dt_type = 'A' AND 거래일자 between :dt1 and :dt2))
    		or
    		((:dt_type = 'B' AND 거래일자 between :dt1 and :dt2))
    ```
    
2. LIKE/BETWEEN 조건 활용
    
    필수 조건이 변별력이 좋은 경우 나쁘지 않다.
    
    ```sql
    -- 인덱스 : 상품대분류코드 + 상품코드
    select * from 상품
    where 상품대분류코드 = :prd_lcls_cd  // 필수 조건
    and 상품코드 like :prd_cd || '%' // 옵션 조건
    ```
    
    LIKE/BETWEEN 을 사용할 때 아래 조건에 속하는지 반드시 점검해야한다(BETWEEN은 위의 2개)
    
    - 인덱스 선두 컬럼 → 값이 입력되지 않으면 인덱스에서 모두 검색해서 필터링해야함
    - NULL 허용 컬럼 → 결과 집합에 오류가 생김(null은 like '%'에 검색되지 X)
    - 숫자형 컬럼 → '%'은 문자 비교 연산이라서 숫자형 컬럼은 형변환 → 인덱스 사용X
    - 가변 길이 컬럼 → 입력값이 있어도 여러 값이 의도하지 않게 검색될 수 있음
3. UNIONALL 활용
    
    ```sql
    select * from 거래
    where :cust_id is null
    and 거래일자 between :dt1 and :dt2  -- 거래 일자가 선두인 인덱스 사용
    union all
    select * from 거래
    where :cust_id is not null
    and 거래일자 between :dt1 and :dt2   -- 고객ID가 선두인 인덱스 사용
    ```
    
    → :cust_id 변수에 값을 입력했는지 하지 않았는지에 따라 두 SQL 중 하나만 실행되는 방식
    
    - null 허용 컬럼이어도 문제 없음
    - 두 경우 모두 인덱스 조건으로 사용한다
    - SQL 코딩량이 길어진다
4. NVL/DECODE 함수 활용
    
    ```sql
    select * from 거래
    where 고객ID = nvl(:cust_id, 고객ID)
    and 거래일자 between :dt1 and :dt2
    
    혹은
    
    select * from 고객
    where 고객ID = decode(:cuxst_id, null, 고객ID, :cust_id)
    and 거래일자 between :dt1 and :dt2
    ```
    
    → :cust_id 값이 없으면 거래일자가 선두인 인덱스 이용, 있으면 고객ID+거래일자 인덱스 사용
    
    - NVL, DECODE 둘 다 실행계획 동일
    - 고객ID를 가공했는데도 인덱스 사용이 가능한 이유는 OR Expansion 쿼리 변환이 일어났기 때문
    - 옵션 조건 컬러도 인덱스 액세스 조건으로 사용할 수 있음
    - UNION ALL보다 단순하면서 UNION ALL과 동일한 성능을 냄
    - 하지만, NULL 허용 컬럼에서는 사용할 수 없다
    - NVL/DECODE 함수를 여러개 사용하면 그 중 가장 변별력이 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어남
5. Dynamic SQL
    - dynamic sql 쓸 수 있으면 사실 옵션 조건에 '=' 사용 가능
    - 하지만 금융권 등 dynamic sql을 허용하지 않는 곳도 있고, 허용하더라도 힌트로 액세스 경로를 고정하려고 할 때 동적으로 구성된 조건절과 서로 상충할 수 있어서 고려해야한다

### 3.3.12 함수호출부하 해소를 위한 인덱스 구성

PL/SQL 사용자 정의 함수는 개발자들이 일반적으로 생각하는 것 이상으로 느리다

<이유>

- 가상머신(VM) 상에서 실행되는 인터프리터 언어
- 호출 시마다 컨텍스트 스위칭 발생
- 내장 SQL에 대한 Recursive Call 발생

→ 쿼리 내에 풀어서 쓰길 권장

→ 함수 내부 로직이 너무 복잡하면 그대로 쓸 수 밖에 없음. 그럴 땐 효과적인 인덱스 구성을 통해 함수 호출 횟수를 줄이기

### 질문

- 216p 어떤 경우에는 OR Expantion 동작하는지?
- 228p, 229p 함수 호출 횟수 왜,,?
- 222P `where 고객ID = 고객ID`의 의미?