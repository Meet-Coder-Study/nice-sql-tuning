# 3.1 테이블 액세스 최소화

### 3.1.1 테이블 랜덤 액세스

- 인덱스로 검색해도 빠른데 왜 파티셔닝을 할까?
- 인덱스로 검색하는데 왜 느릴까?

### ROWID

- 커버링 인덱스가 아닌 경우 원하는 자료를 찾기 위해 ROWID로 테이블에 액세스 해야한다
- 인덱스의 ROWID는 포인터(물리 주소)가 아니다. 논리 주소이다!(메모리 DB 인덱스는 포인터)

### 인덱스를 이용한 I/O

- ROWID를 분해해서 DBA 정보 확인
- 해싱 결과로 해시 체인 찾기(래치 획득)
- 해시 체인 내부에서 버퍼 헤더 찾기(버퍼 캐시의 메모리 주소)
- 버퍼 헤더가 있으면 포인터로 버퍼 블록 찾아가기(&pinning 포인터 유지)
- 버퍼 헤더가 없으면 디스크에서 데이터 파일 → 블록 → 레코드 찾아가서 캐시에 로딩 & 결과 리턴

→ 버퍼 캐시에서 테이블 블록이 수시로 밀려났다 다시 캐싱됨

⇒ 인덱스에서 포인터 사용할 수 X

⇒ 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용이다!

![Untitled](/img/pic3-3.png)

### Table Full Scan I/O

- 테이블 세그먼트 헤더에 익스텐트 맵 확인
- 익스텐트 맵을 통해 각 익스텐트의 첫 번째 블록 DBA를 알 수 있음
- 익스텐트 내부의 블록은 연결되어 있으므로 시퀀셜하게 읽으면됨

### 3.1.2 인덱스 클러스터링 팩터

특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미 = 군집성 계수

익덱스 레코드 정렬 순서와 실제 테이블 정렬 순서가 비슷하면 테이블 액세스량에 비해 블록 I/O가 적게 발생함

→ 버퍼 Pinning(인덱스 ROWID로 테이블 액세스 할 때, 래치 획득과 체인 스캔 후 블록에서 데이터를 읽고 포인터 그대로 유지)

### 3.1.3 인덱스 손익분기점

ROWID로 테이블 액세스는 고비용 구조

→ 읽어야 할 데이터가 일정량 이상 넘어가면 테이블 풀스캔이 효과적일수도

⇒ Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 인덱스 손익분기점

- 보통 10~100만건 이내 테이블에서 손익 분기점은 5~20% 수준, CF에 따라 크게 달라진다
- 테이블 풀스캔은 1000건을 조회하든, 1000만건을 조회하든 성능이 거의 일정하다
    
    → 시퀀셜 액세스, Multiblock I/O라서
    

### OLTP 튜닝

- 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 중요
- NL 조인 사용
- 인덱스로 소트 연산 생략

### 배치 프로그램 튜닝

- 전체범위 처리 기준으로 튜닝해야 한다
- 처리 대싱 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표로
- 대량 데이터를 빠르게 처리하려면 Full Scan과 해시 조인이 유리
- 초대용량 테이블을 Full Scan하면 오래 걸리기 때문에 배치 프로그램은 파티션 활용 전략이 매우 중요한 튜닝 요소
- 파티셔닝은 Full Scan을 빠르게 처리하기 위함

### 3.1.4 인덱스 컬럼 추가

테이블 액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼 추가 하는 것

- 인덱스 스캔 후, 테이블 액세스 과정에서 필터되는 데이터가 많은 경우 사용

cr - Consistent Read(Consistent Read Mode로 버퍼 캐시에서 특정 블록을 읽는 것)

pr - Physical Read(특정 블록을 읽어서 버퍼 캐시에 로딩)

### 3.1.5 인덱스만 읽고 처리

### Covered 쿼리, Covered 인덱스

쿼리에 사용되는 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않도록 하는 방법

### Include 인덱스

인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능(최대 1023 컬럼까지 지정 가능)

- 커버링 인덱스랑 차이점: 커버링 인덱스와 달리 수직 탐색에 사용할 수 없다, 정렬도 X
- 인덱스 생성 시, `include (sal)`

### 3.1.6 인덱스 구조 테이블

- 클러스터형 인덱스, IOT
- 인덱스 리프 블록에서 테이블 블록에 있어야 할 데이터를 모두 저장
- 인위적으로 클러스터링 팩터를 좋게 만드는 방법 → 시퀀셜 데이터 액세스
- 테이블 생성할 때, `organization index` 작성(기본 테이블은 힙 구조 테이블)

### 3.1.7 클러스터 테이블

- 인덱스를 이용한 클러스터, 해시 클러스터 존재

### 질문

- 129p 파티션 pruning: 하드 파싱이나 실행 시점에서 SQL 조건절을 분석해서 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외시키는 기능
- 콤마는 암시적 inner join
- 랜덤 I/O를 줄여야한다고 할 때, 디스크 블록 I/O(테이블 액세스)만 말하는 게 아니라 버퍼 캐시 읽는 것도 포함인듯?
- 142p 실행 계획 읽는 순서?
- 윈도우 함수?
- include의 커버링 인덱스 대비 우위점: 갱신 시 인덱스 트리 재정렬 오버헤드 X
- 152p 클러스터링 인덱스가 수정되면 데이터 전체 재정렬?
- 클러스터 vs 파티셔닝 → 파티셔닝 테이블을 물리적으로 분리해서 I/O 경합으르 줄이기 위함, 클러스터는 CF를 높이기 위한 목적
- 클러스터 없이 쓰면 배치로 여러 데이터 입력되도 다른 블록에 저장될까? CF 나빠질까?

[SQL 실행계획(Explain Plan) 해석/읽는 법](https://m.blog.naver.com/jump_penguin/20193916878)

# 3.2 부분범위 처리 활용

### 3.2.1 부분범위 처리

- DBMS는 클라이언트에게 데이터를 전송할 때 일정량씩 나누어 전송
- 일정량(Array Size) 전송하고 서버 프로세스는 CPU를 OS에 반환
- 클라이언트로부터 Fetch Call을 받기 전까지 서버 프로세스는 대기 큐에서 그대로 멈춰 기다림
- 정렬 조건이 있으면 정렬을 완료한 후 전송할 데이터를 나눌 수 있기 때문에 성능 개선 불가능
- 정렬 조건이 인덱스의 선두에 있으면 부분 범위 처리 가능
- 대량 데이터를 파일로 내려받는다면 어차피 데이터를 모두 전송해야 하므로 Array Size를 크게 하고 Fetch Call을 줄임
- 일부 데이터만 Fetch하다가 멈추는 프로그램은 Array Size를 작게 설정하는 것이 유리

### 3.2.2 부분범위 처리 구현

Array Size에 도달하면 멈추었다가 사용자 요청이 있을 때 다시 데이터를 Fetch하는 부분이 필요하다

### 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리

클라이언트 - DB 서버 2-Tier 환경은 일부만 출력하고 멈출 수 있다

클라이언트와 DB 사이에 WAS, AP 서버 등이 존재하는 n-Tire는 클라이언트가 특정 DB 커텍션을 독점할 수 없 → 5.3장에서 방법 설명

# 3.3 인덱스 스캔 효율화

### 3.3.3 액세스 조건과 필터 조건

- 인덱스 액세스 조건: 인덱스 스캔 범위를 결정하는 조건절
- 인덱스 필터 조건: 테이블로 엑세스 할지 결정하는 조건절
- 테이블 필터 조건: 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지 결정

### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

- 인덱스 엑세스 조건: 선행 컬럼이 '='인 조건 상태에서 첫 번째로 나타나는 범위 검색 조건까지
    
    → 조건에 만족하는 인덱스 레코드는 연속해서 모여있음
    
- 인덱스 필터 조건: 그 이후는 비교 연산자 종류에 상관없이 결과가 흩어짐