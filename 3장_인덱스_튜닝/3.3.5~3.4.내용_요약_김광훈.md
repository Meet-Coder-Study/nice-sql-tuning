# 3.3.5 인덱스 선행 컬럼이 등치 조건이 아닐 때 생기는 비효율
인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치 조건으로 사용할 때 가장 좋다.

리프 블록을 스캔하면서 읽은 레코드는 하나도 걸러지지 않고 모두 테이블 엑세스로 이어지므로 인덱스 스캔 단게에서의 비효율은 전혀 없다.


# 3.3.6 BETWEEN 을 IN-LIST 로 전환
BETWEEN 조건을 IN-LIST 로 바꿀 수 있다.

IN-List 개수만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 칼럼을 '=' 조건으로 검색하므로 앞서 선두 컬럼에 BETWEEN 을 사용할 때와 같은 비효율은 사라진다.

# 3.3.8 IN 조건은 '=' 인가
정리하자면 IN 조건은 = 이 아니다. IN 조건이 '=' 이 되려면 IN-List Iterator 방식으로 풀려야한다.

그렇지 않다면 IN 조건은 필터 조건이다.

즉, IN 은 엑세스 조건 또는 필터 조건으로 사용할 수 있다.

# 3.3.9 BETWEEN 과 LIKE 스캔 범위 비교 
결론부터 말하자면 LIKE 보다 BETWEEN 을 사용하는 것이 낫다.

BETWEEN 은 다소 불편하지만 LIKE 보다 효율적이다. 예를들어 `WHERE LIKE '2019%' AND 판매구분 = 'B'` 로 쿼리를 날린다면 201901, 201900 등등 계속 찾아야한다.

# 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교
인덱스 선두 컬럼에는 OR 조건을 사용해서는 안된다. --> 인덱스 스캔을 못함 

OR 조건 정리 
```
1. 인덱스 액세스 조건으로 사용 불가
2. 인덱스 필터 조건으로도 사용 불가
3. 테이블 필터 조건으로만 사용 가능 
```

# 3.4.1 인덱스 설계가 어려운 이유
인덱스가 많으면 생기는 문제
```
1. DML 성능 저하 
2. 데이터베이스 사이즈 증가
3. 데이터베이스 관리 및 운영 비용 상승 
```

# 3.4.2 가장 중요한 두 가지 선택 기준
Index Range Scan 을 사용하기 위해서는 인덱스 선두 컬럼을 조건절에 반드시 사용해야 한다.

따라서 결합 인덱스를 구성할 때 첫 번째 기준은, 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정하는 것이다.

두 번째 기준은, 그렇게 선정한 컬럼 중 '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 두어야 한다.

# 3.4.5 소트 연산을 생략하기 위한 컬럼 추가
인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY 를 위한 소트 연산을 생략할 수 있게 해 준다.

따라서 조건절에 사용하지 않는 컬럼이더라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선에 도모할 수 있다.

# 3.4.6 결합 인덱스 선택도
인덱스 생성 여부를 결정할 때는 선택도가 충분히 낮은지가 중요한 판단 기준임

선택도: 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율 -> 선택도 x 총 레코스 = 카디널리티 

인덱스 선택도: 인덱스 칼럼을 모두 '=' 로 조회할 때 평균적으로 선택되는 비율 -> 비율이 높으면 인덱스로서의 효용가치가 없다.