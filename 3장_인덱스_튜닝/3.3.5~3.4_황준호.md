### 3.3 인덱스 스캔 효율화

- 인덱스 선두 컬럼이 = 조건일때 효율적이다

  - 인덱스 선행 컬럼이 범위 검색일 경우 비효율적이다
  - 범위 검색을 하는 컬럼을 인덱스 선행 컬럼이 아니도록 수정하는 게 어렵다면 between을 in으로 바꾸면 효과를 얻는 경우도 있다
    - 하지만 in-list 개수가 많다면 더 비효율적으로 될수도 있다
    - 바꾸기 전에 데이터 분포와 수직적 탐색 비용을 고려해야 한다

- between보단 like를 쓰는게 더 효율적이다

- between, like 패턴을 사용하고자 할 땐 아래의 경우에 속하는지 고려해야 한다

  1. 인덱스 선두 컬럼에 대한 옵션 조건을 between, like 연산자로 처리하면 안된다
  2. null 허용 컬럼에 대한 옵션 조건을 between, like 연산자로 처리하면 안된다
  3. 숫자형 컬럼에 대한 옵션 조건을 like연산자로 처리하면 안된다
  4. like를 옵션조건에 사용할 때는 컬럼 값 길이가 고정적이어야 한다

- 옵션 조건을 처리하는 가장 효율적인 방법은 union all을 이용하는 것이다

  ```sql
  -- 인덱스 : a + b
  -- a는 옵션 조건
  select *
  from table_name
  where :a_input is null and b between :b_input1 and :b_input2
  union all
  select *
  from table_name
  where :a_input is not null and a = :a_input and b between :b_input1 and :b_input2
  ```

### 3.4 인덱스 설계

- 인덱스 설계가 어려운 이유? SQL 각각에 최적화된 인덱스를 마음껏 생성할 수 없기 때문에

  - 인덱스가 늘어나면 늘어날수록 DML 성능저하, 데이터베이스 사이즈 증가, 관리비용 상승 등의 문제가 커진다

- 결합 인덱스를 구성할때의 가장 중요한 두가지 (판단 기준이 인덱스 스캔 효율성일때)

  1. 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정해야 한다
  2. 그렇게 선정한 컬럼 중 = 조건으로 자주 조회하는 컬럼을 앞쪽에 두어야 한다

- 인덱스 스캔 효율성 외에도 다른 판단 기준들도 많다

  - 수행 빈도 (효율성 다음으로 가장 중요)
    - NL방식으로 조인하는 두 테이블이 있을 때, outer쪽 인덱스보다 inner쪽 인덱스가 더 중요하다
  - 업무상 중요도
  - 클러스터링 팩터
  - 데이터량
    - 데이터량이 적으면 인덱스가 많던 적던 크게 이슈가 되지 않는다
    - 대용량이라면, 인덱스가 중요하다
  - DML부하
  - 저장 공간
  - 인덱스 관리 비용 등

- 인덱스는 order by, group by를 위한 소트 연산을 생략할 수 있게 해준다

  - I/O를 최소화하면서도 소트 연산을 생략하려면..
    1. = 연산자로 사용한 조건절 컬럼 선정
    2. order by 절에 기술한 컬럼 추가
    3. = 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

- 항상 사용하는 컬럼을 앞쪽에 두고 그 중 = 조건을 앞쪽에 위치시켜야 효율적이다

  - 예: 조건절로 인덱스 설계하기

    ```sql
    -- 조건절1
    where a = :v1
    and b = :v2
    and c >= :v3
    -- 조건절2
    where a = :v1
    and b = :v2
    and c >= :v3
    and d = :v4
    -- 조건절3
    where a = :v1
    and b = :v2
    and c >= :v3
    and e = :v5
    -- 조건절4
    where a = :v1
    and b = :v2
    and c >= :v3
    and d = :v4
    and e = :v5
    ```

    - a,b,c는 항상 들어가고, d,e은 선택이므로 a,b,c먼저, d,e는 뒤로 배치한다

    - a,b는 = 조건이고, c는 between조건으므로 a,b가 c보다 앞에 배치된다

    - a,b사이와 d,e사이는 어떤게 앞에 오더라도 상관없다

      -> 효율적인 인덱스 순서 : abcde, abced, bacde, baced

- 인덱스 중복 제거

  - 실습1

    - 상황

      X01: a + b

      X02: a + b + c

      X03: a + b + c + d

    - 해결

      X03만 남기고 X01, X02는 제거해도 된다

  - 실습2

    - 상황

      X01: a + b

      X02: a + c

      X03: a + d

      X04: a + e

      (+) a의 평균 카디널리티가 매우 낮다

    - 해결

      카디널리티가 매우 낮다면 사실상 중복이다. 카디널리티가 5라면 a 를 =조건으로 조회하면 평균 5건이 남으니까 인덱스를 4개씩 만들 필요가 없다. 모두 제거하고 다음 인덱스 하나만 남겨도 된다

      X01: a + b + c + d + e

  - 실습3

    - 상황

      PK: <u>a</u> + b + c

      N1: d + <u>a</u>

      N2: <u>f</u> + b

      N3: <u>a</u> + e

      N4: <u>a</u> + d

      밑줄(a, f) : 항상 범위조건으로만 조회

      컬럼에 입력된 값 종류 개수 : <u>a</u>(2356), b(127), c(1850), d(5956), e(1715), <u>f</u>(2356)

    - 해결1

      a가 항상 범위조건이면 N3와 N4는 둘다 a가 인덱스 액세스 조건이다.

      그래서 N4를 지우고 N3 맨뒤에 d를 추가한다

    - 해결2

      d와 a로 조회하거나 d단독으로 조회할때는 N1을 사용하고, a만으로 조회할때는 N3을 쓰면 되니까 N4만 제거해도 된다

    - 해결3

      PK: b + a + c

      N1: d + a

      N2: f + b

      N3: a + e

      ~~N4: a + d~~

  - 실습4

    - 상황

      PK: a + b + c + d

      N1: e + d

      N2: d

      N3: a + d

      컬럼에 입력된 값 종류 개수 : a(736000), b(175), c(3000), d(250000), e(3)

    - 해결

      e의 NDV가 매우 낮기 때문에 e로만 조회할 땐 N1인덱스가 사용되지 않는다

      N2를 제거하고 N1의 e와 d의 순서를 바꾼다